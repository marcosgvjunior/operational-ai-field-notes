"""
Pretrained semantic segmentation inference utilities.

Design goals
------------
- Minimal notebook boilerplate: notebook loads images, src does the rest.
- Explicit I/O: inputs and outputs are clear, no hidden global state.
- SRP: this module handles inference + safe preprocessing only (no visualization).

Notes
-----
This uses torchvision pretrained semantic segmentation models (PASCAL VOC classes).
"""

from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import Literal

import numpy as np
import torch
from PIL import Image
from torchvision.models.segmentation import (
    DeepLabV3_ResNet50_Weights,
    FCN_ResNet50_Weights,
    deeplabv3_resnet50,
    fcn_resnet50,
)

SegmentationModelName = Literal["deeplabv3_resnet50", "fcn_resnet50"]


@dataclass(frozen=True)
class LoadedSegmentationModel:
    """
    Loaded segmentation model + preprocessing metadata.

    :ivar name: Model identifier.
    :ivar model: Torch module in eval mode.
    :ivar weights_name: String representation of the weights used.
    :ivar preprocess: Callable transform generated by weights.transforms().
    :ivar categories: Class labels (if provided by weights metadata).
    :ivar device: Torch device string.
    """
    name: SegmentationModelName
    model: torch.nn.Module
    weights_name: str
    preprocess: object
    categories: list[str]
    device: str


def _default_device() -> str:
    """
    Choose the best available device.

    :returns: "cuda" if available, else "cpu".
    """
    return "cuda" if torch.cuda.is_available() else "cpu"


def load_pretrained_segmentation_model(
    name: SegmentationModelName = "deeplabv3_resnet50",
    device: str | None = None,
) -> LoadedSegmentationModel:
    """
    Load a pretrained semantic segmentation model from torchvision.

    :param name: One of {"deeplabv3_resnet50", "fcn_resnet50"}.
    :param device: Torch device string. If None, uses CUDA when available.
    :returns: Loaded model container.
    """
    dev = _default_device() if device is None else device

    if name == "deeplabv3_resnet50":
        weights = DeepLabV3_ResNet50_Weights.DEFAULT
        model = deeplabv3_resnet50(weights=weights)
    elif name == "fcn_resnet50":
        weights = FCN_ResNet50_Weights.DEFAULT
        model = fcn_resnet50(weights=weights)
    else:
        raise ValueError(f"Unsupported model name: {name}")

    model.eval()
    model.to(dev)

    preprocess = weights.transforms()
    categories = list(weights.meta.get("categories", []))

    return LoadedSegmentationModel(
        name=name,
        model=model,
        weights_name=str(weights),
        preprocess=preprocess,
        categories=categories,
        device=dev,
    )


def segment_semantic(
    image: Image.Image,
    loaded: LoadedSegmentationModel | None = None,
    model_name: SegmentationModelName = "deeplabv3_resnet50",
    device: str | None = None,
) -> np.ndarray:
    """
    Run semantic segmentation on a single image.

    This function is notebook-friendly: it can lazy-load a default model if
    ``loaded`` is not provided. It also guarantees RGB conversion.

    :param image: PIL image in any mode. It will be converted to RGB internally.
    :param loaded: Pre-loaded model container. If None, the model is loaded on demand
        using ``model_name`` and ``device``.
    :param model_name: Model to load when ``loaded`` is None.
    :param device: Device used when loading the model on demand.
    :returns: Integer class map of shape (H, W), dtype int64.
    """
    model_container = loaded
    if model_container is None:
        model_container = load_pretrained_segmentation_model(model_name, device=device)

    img_rgb = image.convert("RGB")
    x = model_container.preprocess(img_rgb).unsqueeze(0).to(model_container.device)

    with torch.no_grad():
        out = model_container.model(x)

    logits = out["out"][0]  # (C, H, W)
    class_map = torch.argmax(logits, dim=0).to("cpu").numpy().astype(np.int64)
    return class_map


def save_class_map_npz(class_map: np.ndarray, out_path: str | Path) -> Path:
    """
    Save a class map to a compressed NPZ file.

    :param class_map: Array (H, W) with integer class ids.
    :param out_path: Destination path to .npz.
    :returns: Resolved path to saved file.
    """
    p = Path(out_path)
    p.parent.mkdir(parents=True, exist_ok=True)
    np.savez_compressed(p, class_map=class_map)
    return p.resolve()
